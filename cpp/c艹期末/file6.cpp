#undef UNICODE#include "windows.h"#include<iostream>#include <stdio.h>#include <cstring>#include <stdlib.h>#include <string>#include <CommDlg.h>#include "tchar.h"#include <Shlobj.h>using namespace std;class text {public:	virtual void display() {}};class File :public text {public:	void display() {		cout << "-----------------" << endl;		cout << "|        File           |" << endl;		cout << "-----------------" << endl;	}};class Folders :public text {public:	void display() {		cout << "-----------------" << endl;		cout << "|        Folder           |" << endl;		cout << "|                         |" << endl;		cout << "-----------------" << endl;	}};int main(int argc, char* argv[]){	File fil;	Folders fol;	/*	TCHAR szBuffer[MAX_PATH] = { 0 };	OPENFILENAME file = { 0 };	file.hwndOwner = NULL;	file.lStructSize = sizeof(file);	file.lpstrFilter = "所有文件(*.*)\0*.*\0";//要选择的文件后缀	file.lpstrInitialDir = "C:\\";//默认的文件路径	file.lpstrFile = szBuffer;//存放文件的缓冲区	file.nMaxFile = sizeof(szBuffer) / sizeof(*szBuffer);	file.nFilterIndex = 0;	file.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_EXPLORER;//标志如果是多选要加上OFN_ALLOWMULTISELECT	BOOL bSel = GetOpenFileName(&file);	//printf("file: %s", file.lpstrFile);	string filePath = file.lpstrFile;	int start = filePath.find_last_of('\\'); //获取最后一个\\的索引	int end = filePath.find_last_of('.'); //获取最后一个.的索引	string filepath = filePath.substr(0, start + 1);	*/	TCHAR szBuffer[MAX_PATH] = { 0 };   //存放选择文件的路径 	BROWSEINFO bi;	ZeroMemory(&bi, sizeof(BROWSEINFO));	bi.hwndOwner = NULL;	bi.pszDisplayName = szBuffer;	//bi.lpszTitle = _T("从下面选择文件或文件夹:");   //_T()是在头文件tchar.h下的一个宏定义。 	bi.ulFlags = BIF_BROWSEINCLUDEFILES;	LPITEMIDLIST idl = SHBrowseForFolder(&bi);   //开始选择文件或文件夹	if (NULL == idl)	{		return 0;	}	SHGetPathFromIDList(idl, szBuffer);	//获取完整路径，否则szBuffer只会存储当前选择的文件或文件夹名称	cout << "您选择的文件或文件夹的路径为：\n" << szBuffer << endl;	OPENFILENAME file = { 0 };	file.lpstrFile = szBuffer;//存放文件的缓冲区 	file.nMaxFile = sizeof(szBuffer) / sizeof(*szBuffer);	file.nFilterIndex = 0;	file.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_EXPLORER;//标志如果是多选要加上OFN_ALLOWMULTISELECT	string filePath = file.lpstrFile;	//cout << filePath << endl;	string::size_type idx = filePath.find(".");	if (idx != string::npos)	{		fil.display();	}	else	{		fol.display();	}	//int start = filePath.find_last_of('\\'); //获取最后一个\\的索引	//int end = filePath.find_last_of('.'); //获取最后一个.的索引	//string filepath = filePath.substr(0, start + 1);	//cout << filepath << endl;	/*WIN32_FIND_DATAA FindFileData;FindFirstFileA("filepath", &FindFileData);//FindFirstFileA(tempPath,&FindFileData);if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {	fil.display(); }else{	fol.display();}*///string fileName = filePath.substr(start + 1, end - start - 1);//string exten = filePath.substr(end, filePath.length() - end);}